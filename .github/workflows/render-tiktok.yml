name: Render TikTok (centrado, chip visible y cover XL)

on:
  workflow_dispatch:
    inputs:
      out_name:
        description: Nombre del archivo de salida
        required: true
        default: futurocientifico.mp4
      text1:
        description: Texto 1 (branding)
        required: false
        default: "FuturoCient칤fico 췅 Ciencia en 1 minuto"
      text3:
        description: Texto 3 (CTA)
        required: false
        default: "#Ciencia #Curiosidades #FuturoCient칤fico"
      text4:
        description: "Redes (separadas por ' 췅 ')"
        required: false
        default: "IG:@futurocientifico2025 췅 TikTok:@futurocientifico 췅 X:@futuro100tico 췅 YouTube:@futurocientifico"
      duration:
        description: Duraci칩n del v칤deo (segundos)
        required: true
        default: "59"
      title_style:
        description: "Plantilla del t칤tulo: strip | card | glow"
        required: false
        default: "strip"

permissions:
  contents: write

env:
  TZ: Europe/Madrid
  IMAGE_PATH: public/avatar-cientifico.png
  DEFAULT_MUSIC_URL: "https://freepd.com/music/Adventure.mp3"
  PROMPT_TEMPLATE_FILE: scripts/prompt-template.txt

jobs:
  render:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Instalar ffmpeg, jq e ImageMagick (fuentes + emoji)
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg jq imagemagick fonts-dejavu-core fonts-noto-color-emoji

      - name: Preparar carpeta por fecha
        run: |
          set -euo pipefail
          TODAY="$(date +%F)"
          OUTDIR="media/${TODAY}"
          mkdir -p "${OUTDIR}"
          echo "TODAY=${TODAY}" >> "$GITHUB_ENV"
          echo "OUTDIR=${OUTDIR}" >> "$GITHUB_ENV"

      - name: Verificar enriched e imagen
        run: |
          set -euo pipefail
          test -s public/articles_enriched.json || { echo "Falta public/articles_enriched.json"; exit 1; }
          test -s "$IMAGE_PATH" || { echo "Falta $IMAGE_PATH"; exit 1; }

      - name: Elegir 칰ltimo art칤culo y preparar textos (wrap + tama침os + redes 2 l칤neas + chip)
        id: pick
        run: |
          set -euo pipefail
          FILE="public/articles_enriched.json"
          SEL="$(jq -c 'sort_by(.published // .date) | reverse | .[0]' "$FILE")"
          TITLE_ES="$(printf '%s' "$SEL" | jq -r '(.title_es // "")')"
          SOURCE="$(printf '%s' "$SEL" | jq -r '(.source // "")')"
          PUBL="$(printf '%s' "$SEL" | jq -r '(.published // .date // "")')"
          DATE="${PUBL%%T*}"
          URL="$(printf '%s' "$SEL" | jq -r '(.url // "")')"

          [ -n "$TITLE_ES" ] && [ "$TITLE_ES" != "null" ] || { echo "El 칰ltimo art칤culo no tiene title_es"; exit 1; }

          {
            echo "AUTO_TITLE_ES=$TITLE_ES"
            echo "AUTO_SOURCE=$SOURCE"
            echo "AUTO_DATE=$DATE"
            echo "AUTO_URL=$URL"
          } >> "$GITHUB_ENV"

          # Tama침o/ajuste del t칤tulo (v칤deo)
          LEN=$(printf "%s" "$TITLE_ES" | wc -m | awk '{print $1}')
          if   [ "$LEN" -le 60  ]; then FONT_T2=38; WRAP=28
          elif [ "$LEN" -le 100 ]; then FONT_T2=32; WRAP=24
          elif [ "$LEN" -le 140 ]; then FONT_T2=28; WRAP=20
          else                         FONT_T2=24; WRAP=18
          fi
          echo "FONT_T2=${FONT_T2}" >> "$GITHUB_ENV"

          # Versi칩n para COVER (m치s grande, con tope)
          COVER_T2=$((FONT_T2 + 18)); if [ "$COVER_T2" -gt 68 ]; then COVER_T2=68; fi
          echo "FONT_T2_COVER=${COVER_T2}" >> "$GITHUB_ENV"

          # Fuentes m치s grandes en cover
          echo "FONT_T1_COVER=42"   >> "$GITHUB_ENV"   # branding
          echo "FONT_CHIP_TEXT=42"  >> "$GITHUB_ENV"   # chip texto
          echo "FONT_CHIP_EMOJI=72" >> "$GITHUB_ENV"   # chip emoji
          echo "FONT_T3_COVER=36"   >> "$GITHUB_ENV"   # CTA
          echo "FONT_T4_COVER=34"   >> "$GITHUB_ENV"   # redes

          # Textos base
          printf "%s" "${{ github.event.inputs.text1 }}" > t1.txt
          printf "%s" "$TITLE_ES" | fold -s -w ${WRAP} > t2.txt
          printf "%s" "${{ github.event.inputs.text3 }}" > t3.txt

          # Redes en dos l칤neas
          T4_IN="${{ github.event.inputs.text4 }}"
          printf "%s\n" "$T4_IN" | awk -F "췅" '{
            n=split($0,a,"췅"); mid=int((n+1)/2);
            for(i=1;i<=mid;i++){gsub(/^ +| +$/,"",a[i]); printf "%s%s", a[i], (i<mid?" 췅 ":"")}
            print "";
            for(i=mid+1;i<=n;i++){gsub(/^ +| +$/,"",a[i]); printf "%s%s", a[i], (i<n?" 췅 ":"")}
            print "";
          }' > t4_split.txt
          sed -n '1p' t4_split.txt > t4a.txt
          sed -n '2p' t4_split.txt > t4b.txt

          # Chip (emoji y texto separados)
          echo "游닉" > t2chip_emoji.txt
          echo "Hoy en #FuturoCient칤fico" > t2chip_text.txt

          # Estilo
          STYLE="${{ github.event.inputs.title_style }}"
          case "$STYLE" in
            strip|card|glow) echo "TITLE_STYLE=$STYLE" >> "$GITHUB_ENV" ;;
            *) echo "TITLE_STYLE=strip" >> "$GITHUB_ENV" ;;
          esac

      - name: Preparar audio
        run: |
          set -euo pipefail
          DUR="${{ github.event.inputs.duration }}"
          IN=""
          if [ -s "public/audio/default.mp3" ]; then
            IN="public/audio/default.mp3"
          else
            if curl -L --fail -o default_music.mp3 "${DEFAULT_MUSIC_URL}"; then IN="default_music.mp3"; fi
          fi
          if [ -z "$IN" ]; then
            ffmpeg -y -f lavfi -t "$DUR" -i anullsrc=r=44100:cl=stereo -c:a aac -b:a 128k music_in.m4a
          else
            ffmpeg -y -i "$IN" -vn -ac 2 -ar 44100 -c:a aac -b:a 128k -filter:a "volume=0.9" music_in.m4a
          fi

      - name: Renderizar v칤deo (igual que antes)
        run: |
          set -euo pipefail
          OUT="${{ github.event.inputs.out_name }}"
          DUR="${{ github.event.inputs.duration }}"
          FONT="/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf"
          FONT_BOLD="/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf"

          VF="scale=1080:-2,pad=1080:1920:(ow-iw)/2:(oh-ih)/2,format=yuv420p"
          case "$TITLE_STYLE" in
            strip) VF="$VF,drawbox=x=0:y=(h/2-230):w=iw:h=460:color=0x000000CC:t=fill" ;;
            card)  VF="$VF,drawbox=x=(w-960)/2:y=(h/2-260):w=960:h=520:color=0x000000CC:t=fill" ;;
            glow)  : ;;
          esac
          VF="$VF,drawtext=fontfile=${FONT}:textfile=t1.txt:reload=1:text_shaping=1:fontsize=26:fontcolor=white:box=1:boxcolor=0x000000AA:boxborderw=10:x=(w-text_w)/2:y=90"
          VF="$VF,drawtext=fontfile=${FONT_BOLD}:textfile=t2chip_text.txt:reload=1:text_shaping=1:fontsize=26:fontcolor=white:borderw=3:bordercolor=black@1.0:shadowcolor=black@0.85:shadowx=2:shadowy=2:box=1:boxcolor=0x000000AA:boxborderw=8:x=(w-text_w)/2:y=(h/2-300)"
          VF="$VF,drawtext=fontfile=${FONT_BOLD}:textfile=t2.txt:reload=1:text_shaping=1:fontsize=${FONT_T2}:fontcolor=white:borderw=4:bordercolor=black@1.0:shadowcolor=black@0.85:shadowx=2:shadowy=2:line_spacing=8:box=0:x=(w-text_w)/2:y=(h-text_h)/2"
          VF="$VF,drawtext=fontfile=${FONT}:textfile=t3.txt:reload=1:text_shaping=1:fontsize=26:fontcolor=white:box=1:boxcolor=0x000000AA:boxborderw=10:x=(w-text_w)/2:y=1500"
          VF="$VF,drawtext=fontfile=${FONT}:textfile=t4a.txt:reload=1:text_shaping=1:fontsize=24:fontcolor=white:box=1:boxcolor=0x000000AA:boxborderw=8:x=(w-text_w)/2:y=1650"
          VF="$VF,drawtext=fontfile=${FONT}:textfile=t4b.txt:reload=1:text_shaping=1:fontsize=24:fontcolor=white:box=1:boxcolor=0x000000AA:boxborderw=8:x=(w-text_w)/2:y=1740"

          ffmpeg -y -loop 1 -framerate 30 -i "$IMAGE_PATH" -i music_in.m4a -t "$DUR" \
            -filter:v "$VF" -c:v libx264 -pix_fmt yuv420p -profile:v high -preset veryfast -crf 23 \
            -c:a aac -b:a 128k -shortest "$OUT"
          mv "$OUT" "$OUTDIR/$OUT"

      - name: Generar emoji PNG para cover
        run: |
          set -euo pipefail
          # Intento con Noto Color Emoji (emoji real)
          if convert -size 256x256 xc:none -gravity center \
               -font 'Noto Color Emoji' -pointsize ${FONT_CHIP_EMOJI} \
               -fill white -annotate 0 '游닉' chip_emoji.png 2>/dev/null; then
            echo "Emoji 游닉 generado con Noto Color Emoji"
          else
            # Fallback: usa '!' en negrita si no renderiza color emoji
            convert -size 256x256 xc:none -gravity center \
               -font '/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf' -pointsize ${FONT_CHIP_EMOJI} \
               -fill white -annotate 0 '!' chip_emoji.png
            echo "Fallback usando '!'"
          fi

      - name: Generar cover.png (emoji overlay + fuentes XL)
        run: |
          set -euo pipefail
          FONT="/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf"
          FONT_BOLD="/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf"
          BOX_FILTER=""
          case "$TITLE_STYLE" in
            strip) BOX_FILTER=",drawbox=x=0:y=(h/2-320):w=iw:h=720:color=0x000000CC:t=fill" ;;
            card)  BOX_FILTER=",drawbox=x=(w-1000)/2:y=(h/2-340):w=1000:h=720:color=0x000000CC:t=fill" ;;
            glow)  BOX_FILTER="" ;;
          esac

          ffmpeg -y -loop 1 -i "$IMAGE_PATH" -i chip_emoji.png -frames:v 1 \
            -filter_complex "[0:v]scale=1080:-2,pad=1080:1920:(ow-iw)/2:(oh-ih)/2,format=rgba${BOX_FILTER},\
drawtext=fontfile=${FONT}:textfile=t1.txt:reload=1:text_shaping=1:fontsize=${