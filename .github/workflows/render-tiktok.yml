name: Render TikTok (title_es + cover + prompt + IG/X + Drive)

on:
  workflow_dispatch:
    inputs:
      out_name:
        description: Nombre del archivo de salida
        required: true
        default: futurocientifico.mp4
      text1:
        description: Texto 1 (branding)
        required: false
        default: "FuturoCientÃ­fico Â· Ciencia en 1 minuto"
      text3:
        description: Texto 3 (CTA)
        required: false
        default: "#Ciencia #Curiosidades #FuturoCientÃ­fico"
      text4:
        description: Texto 4 (redes)
        required: false
        default: "IG:@futurocientifico2025 Â· TikTok:@futurocientifico Â· X:@futuro100tico Â· YouTube:@futurocientifico"
      hashtags_ig:
        description: Hashtags para Instagram
        required: false
        default: "#Ciencia #DivulgaciÃ³n #FuturoCientÃ­fico"
      hashtags_x:
        description: Hashtags para X
        required: false
        default: "#Ciencia #FuturoCientÃ­fico"
      duration:
        description: DuraciÃ³n del vÃ­deo (segundos)
        required: true
        default: "59"

permissions:
  contents: write

env:
  TZ: Europe/Madrid
  IMAGE_PATH: public/avatar-cientifico.png
  DEFAULT_MUSIC_URL: "https://freepd.com/music/Adventure.mp3"
  PROMPT_TEMPLATE_FILE: scripts/prompt-template.txt

jobs:
  render_and_publish:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Instalar ffmpeg, jq, ImageMagick, fuentes y rclone
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg jq imagemagick fonts-dejavu-core rclone

      - name: Preparar carpeta por fecha
        id: prep
        run: |
          set -euo pipefail
          TODAY="$(date +%F)"
          OUTDIR="media/${TODAY}"
          mkdir -p "${OUTDIR}"
          echo "TODAY=${TODAY}" >> "$GITHUB_ENV"
          echo "OUTDIR=${OUTDIR}" >> "$GITHUB_ENV"
          echo "today=${TODAY}" >> "$GITHUB_OUTPUT"
          echo "outdir=${OUTDIR}" >> "$GITHUB_OUTPUT"

      - name: Verificar enriched e imagen
        run: |
          set -euo pipefail
          test -s public/articles_enriched.json || { echo "Falta public/articles_enriched.json"; exit 1; }
          test -s "$IMAGE_PATH" || { echo "Falta $IMAGE_PATH"; ls -la public || true; exit 1; }

      - name: Elegir Ãºltimo artÃ­culo (title_es obligatorio)
        id: pick
        run: |
          set -euo pipefail
          FILE="public/articles_enriched.json"
          SEL="$(jq -c 'sort_by(.published // .date) | reverse | .[0]' "$FILE")"
          TITLE_ES="$(printf '%s' "$SEL" | jq -r '(.title_es // "")')"
          SOURCE="$(printf '%s' "$SEL" | jq -r '(.source // "")')"
          PUBL="$(printf '%s' "$SEL" | jq -r '(.published // .date // "")')"
          DATE="${PUBL%%T*}"
          URL="$(printf '%s' "$SEL" | jq -r '(.url // "")')"
          if [ -z "$TITLE_ES" ] || [ "$TITLE_ES" = "null" ]; then
            echo "El Ãºltimo artÃ­culo no tiene title_es"; exit 1
          fi
          {
            echo "AUTO_TITLE_ES=$TITLE_ES"
            echo "AUTO_SOURCE=$SOURCE"
            echo "AUTO_DATE=$DATE"
            echo "AUTO_URL=$URL"
          } >> "$GITHUB_ENV"

      - name: Preparar audio (local â†’ FreePD â†’ silencio)
        run: |
          set -euo pipefail
          DUR="${{ github.event.inputs.duration }}"
          IN=""
          if [ -s "public/audio/default.mp3" ]; then
            IN="public/audio/default.mp3"
          else
            if curl -L --fail -o default_music.mp3 "${DEFAULT_MUSIC_URL}"; then
              IN="default_music.mp3"
            fi
          fi
          if [ -z "$IN" ]; then
            ffmpeg -y -f lavfi -t "$DUR" -i anullsrc=r=44100:cl=stereo -c:a aac -b:a 128k music_in.m4a
          else
            ffmpeg -y -i "$IN" -vn -ac 2 -ar 44100 -c:a aac -b:a 128k music_in.m4a
          fi

      - name: Crear textos para el vÃ­deo
        run: |
          set -euo pipefail
          printf "%s" "${{ github.event.inputs.text1 }}" > t1.txt
          printf "%s" "${AUTO_TITLE_ES}" > t2.txt
          printf "%s" "${{ github.event.inputs.text3 }}" > t3.txt
          printf "%s" "${{ github.event.inputs.text4 }}" > t4.txt

      - name: Renderizar vÃ­deo 1080x1920
        run: |
          set -euo pipefail
          OUT="${{ github.event.inputs.out_name }}"
          DUR="${{ github.event.inputs.duration }}"
          VF="scale=1080:-2,pad=1080:1920:(ow-iw)/2:(oh-ih)/2,format=yuv420p"
          VF="$VF,drawtext=font='DejaVu Sans':textfile=t1.txt:reload=1:fontsize=42:fontcolor=white:box=1:boxcolor=0x00000088:boxborderw=10:x=(w-text_w)/2:y=110"
          VF="$VF,drawtext=font='DejaVu Sans':textfile=t2.txt:reload=1:fontsize=50:fontcolor=white:box=1:boxcolor=0x00000088:boxborderw=10:x=(w-text_w)/2:y=360"
          VF="$VF,drawtext=font='DejaVu Sans':textfile=t3.txt:reload=1:fontsize=38:fontcolor=white:box=1:boxcolor=0x00000088:boxborderw=10:x=(w-text_w)/2:y=1520"
          VF="$VF,drawtext=font='DejaVu Sans':textfile=t4.txt:reload=1:fontsize=32:fontcolor=white:box=1:boxcolor=0x00000088:boxborderw=8:x=(w-text_w)/2:y=1700"
          ffmpeg -y -loop 1 -framerate 30 -i "$IMAGE_PATH" -i music_in.m4a -t "$DUR" -filter:v "$VF" -c:v libx264 -pix_fmt yuv420p -profile:v high -preset veryfast -crf 20 -c:a aac -b:a 128k -shortest "$OUT"
          mv "$OUT" "$OUTDIR/$OUT"

      - name: Generar cover.png
        run: |
          set -euo pipefail
          VF="scale=1080:-2,pad=1080:1920:(ow-iw)/2:(oh-ih)/2,format=rgba"
          VF="$VF,drawtext=font='DejaVu Sans':textfile=t1.txt:reload=1:fontsize=42:fontcolor=white:box=1:boxcolor=0x00000088:boxborderw=10:x=(w-text_w)/2:y=110"
          VF="$VF,drawtext=font='DejaVu Sans':textfile=t2.txt:reload=1:fontsize=50:fontcolor=white:box=1:boxcolor=0x00000088:boxborderw=10:x=(w-text_w)/2:y=360"
          VF="$VF,drawtext=font='DejaVu Sans':textfile=t3.txt:reload=1:fontsize=38:fontcolor=white:box=1:boxcolor=0x00000088:boxborderw=10:x=(w-text_w)/2:y=1520"
          VF="$VF,drawtext=font='DejaVu Sans':textfile=t4.txt:reload=1:fontsize=32:fontcolor=white:box=1:boxcolor=0x00000088:boxborderw=8:x=(w-text_w)/2:y=1700"
          ffmpeg -y -loop 1 -i "$IMAGE_PATH" -frames:v 1 -filter:v "$VF" cover.png
          mv cover.png "$OUTDIR/cover.png"

      - name: Construir prompt y textos IG/X
        uses: actions/github-script@v7
        env:
          OUTDIR: ${{ env.OUTDIR }}
          PROMPT_TEMPLATE_FILE: ${{ env.PROMPT_TEMPLATE_FILE }}
          AUTO_TITLE_ES: ${{ env.AUTO_TITLE_ES }}
          AUTO_SOURCE: ${{ env.AUTO_SOURCE }}
          AUTO_DATE: ${{ env.AUTO_DATE }}
          AUTO_URL: ${{ env.AUTO_URL }}
          IG_HASHTAGS: ${{ github.event.inputs.hashtags_ig }}
          X_HASHTAGS: ${{ github.event.inputs.hashtags_x }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const outdir = process.env.OUTDIR;

            // Prompt
            const tplFile = process.env.PROMPT_TEMPLATE_FILE;
            let template;
            if (tplFile && fs.existsSync(tplFile)) {
              template = fs.readFileSync(tplFile, 'utf8');
            } else {
              template = 'IlustraciÃ³n cientÃ­fica minimalista y moderna sobre: "{{title_es}}".\n'
                       + 'Requisitos:\n'
                       + '- Estilo: vector flat, limpio, accesible, alto contraste; colores amigables WCAG.\n'
                       + '- Nada de texto ni logotipos, sin marcas reales; composiciÃ³n clara y sin saturaciÃ³n.\n'
                       + '- Fondo claro y formas geomÃ©tricas abstractas sutiles.\n'
                       + '- Enfoque divulgativo, tÃ©cnico pero atractivo, sin realismo fotogrÃ¡fico.\n'
                       + '- OrientaciÃ³n cuadrada o 4:5; dejar margen de seguridad.\n'
                       + 'Contexto (no dibujar texto, solo orientar la escena):\n'
                       + '- Fuente: {{source}} | Fecha: {{date}} | URL: {{url}}\n';
            }
            const vars = {
              '{{title_es}}': process.env.AUTO_TITLE_ES || '',
              '{{source}}': process.env.AUTO_SOURCE || '',
              '{{date}}': process.env.AUTO_DATE || '',
              '{{url}}': process.env.AUTO_URL || '',
            };
            let prompt = template;
            for (const [k, v] of Object.entries(vars)) prompt = prompt.split(k).join(v);
            fs.writeFileSync(path.join(outdir, 'prompt.txt'), prompt, 'utf8');

            // IG / X
            const title = (process.env.AUTO_TITLE_ES || '').trim();
            const igTags = (process.env.IG_HASHTAGS || '#Ciencia #DivulgaciÃ³n #FuturoCientÃ­fico').trim();
            const xTags  = (process.env.X_HASHTAGS  || '#Ciencia #FuturoCientÃ­fico').trim();

            const readOr = (p, def) => (fs.existsSync(p) ? fs.readFileSync(p, 'utf8') : def);
            const igTpl = readOr('scripts/ig-template.txt', 'ðŸ’¡ {{title_es}}\n\n{{hashtags}}');
            const xTpl  = readOr('scripts/x-template.txt',  '{{title_es}} â€” #FuturoCientÃ­fico\n\n{{hashtags}}');

            const fill = (tpl, map) => Object.entries(map).reduce((s,[k,v]) => s.split(k).join(v), tpl);
            const igText = fill(igTpl, { '{{title_es}}': title, '{{hashtags}}': igTags });
            const xText  = fill(xTpl,  { '{{title_es}}': title, '{{hashtags}}': xTags  });

            fs.writeFileSync(path.join(outdir, 'instagram.txt'), igText, 'utf8');
            fs.writeFileSync(path.join(outdir, 'x.txt'), xText, 'utf8');

      - name: Subir vÃ­deo como artifact
        uses: actions/upload-artifact@v4
        with:
          name: tiktok-video
          path: ${{ env.OUTDIR }}/*.mp4

      - name: Commit & push media del dÃ­a
        run: |
          set -euo pipefail
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add "${OUTDIR}"
          git commit -m "chore: TikTok + cover + prompt + IG/X (${TODAY}) [skip ci]" || echo "No changes"
          git fetch origin main
          git pull --rebase origin main || true
          git push || (git pull --rebase origin main && git push)

      - name: Subir carpeta del dÃ­a a Google Drive (rclone + SA)
        if: always()
        env:
          GDRIVE_SA_JSON: ${{ secrets.GDRIVE_SA_JSON }}
          GDRIVE_FOLDER_ID: ${{ secrets.GDRIVE_FOLDER_ID }}
        run: |
          set -euo pipefail
          echo "$GDRIVE_SA_JSON" > sa.json
          cat > rclone.conf <<RC
[gdrive]
type = drive
scope = drive
service_account_file = ${PWD}/sa.json
root_folder_id = ${GDRIVE_FOLDER_ID}
RC
          export RCLONE_CONFIG=${PWD}/rclone.conf
          OUTDIR="${OUTDIR:-media/$(date +%F)}"
          TODAY="${TODAY:-$(date +%F)}"
          test -d "$OUTDIR" || { echo "No existe $OUTDIR"; exit 1; }
          rclone mkdir gdrive:"${TODAY}" || true
          rclone -v copy "${OUTDIR}" gdrive:"${TODAY}" --create-empty-src-dirs --checkers=8 --transfers=4 --drive-stop-on-upload-limit
